{"name":"SecureAndroid","tagline":"A small library for encrypting and storing data securely on Android devices.","body":"### Welcome to SecureAndroid\r\nSecureAndroid is a small library that will help you to easily encrypt, decrypt and store data securely on Android devices.\r\nThe library was designed with ease-of-use in mind. You do not have to worry about implementation details of cryptographic algorithms but simply use the provided API. \r\nSecureAndroid uses AES encryption in CBC mode with padding according to PKCS5. For data integrity HMacSHA256 or HMacSHA1 (according to the availability on the device) is used. For key derivation from passwords the PBKDF2WithHmacSHA256/1 (according to the availability on the device) is employed. \r\nSecureAndroid abstracts cryptographic implementation details and i/o-operations away so that you can concentrate on your app logic. \r\n\r\n### Important note\r\nIf you use ProGuard, you need to add the following rule:\r\n\r\n```Java\r\n-keep class my.secureandroid.PRNGFixes$* { *; }\r\n```\r\n\r\n### How to add SecureAndroid to a project\r\nTo use SecureAndroid, simply download the zip or tar.gz file and extract it. In your Android Studio project move to the java folder of your module:\r\n\r\n![](https://dl.dropboxusercontent.com/u/7603573/SecureAndroidUseStep1.png)\r\n\r\nCreate a new package:\r\n\r\n![](https://dl.dropboxusercontent.com/u/7603573/SecureAndroidUseStep2.png)\r\n\r\nChoose your module as the destination:\r\n\r\n![](https://dl.dropboxusercontent.com/u/7603573/SecureAndroidUseStep3.png)\r\n\r\nName the package _my.secureandroid_:\r\n\r\n![](https://dl.dropboxusercontent.com/u/7603573/SecureAndroidUseStep4.png)\r\n\r\nGo to where you extracted the zip or tar.gz file and drag or copy/paste the java classes into the created package folder:\r\n\r\n![](https://dl.dropboxusercontent.com/u/7603573/SecureAndroidUseStep5.png)\r\n\r\nSimply click ok:\r\n\r\n![](https://dl.dropboxusercontent.com/u/7603573/SecureAndroidUseStep6.png)\r\n\r\nThat's it! After importing\r\n\r\n```Java\r\nimport my.secureandroid.SecureAndroid;\r\n```\r\nyou can initialize a SecureAndroid object in your activity like this:\r\n\r\n```Java\r\ntry {\r\n    SecureAndroid sc = new SecureAndroid(MyActivity.this);\r\n} catch (Exception e) {\r\n    // Try it out to see the specific exceptions..and do smth\r\n}\r\n```\r\n\r\n### The API\r\nThe SecureAndroid class is the only class you will have to use. If you want you can take a look into the other classes and build your own little library out of these...but for now let's simply focus on using the public methods of the SecureAndroid class. To get an overview, you can take a look at the [javadocs](https://dl.dropboxusercontent.com/u/7603573/site/javadocs/index.html). If you want to learn about the public API you should look at the documentation of the class _SecureAndroid_.\r\n\r\n\r\n### encrypt/decrypt\r\nLets start with simply encrypting and decrypting some data, for example a string:\r\n```Java\r\n// Encrypt a string\r\nbyte[] ciphertext = sc.encrypt(\"mystring\".getBytes(\"UTF-8\"));\r\n// Decrypt the string\r\nString mystring = new String(sc.decrypt(ciphertext), \"UTF-8\"));\r\n```\r\n\r\nAll key handling and cryptographic operations are done transparently. When the encrypt and decrypt methods are called, SecureAndroid uses an auto-generated password that is device specific. That password is not stored on the device but can be read from it when someone else gets his hands on it. \r\n\r\n\r\n### encryptWithPassword/decryptWithPassword\r\nSo, while the auto-password option is good if you simply want to add a layer of security to your app, if the data to be encrypted is very sensitive, you should provide a password yourself. For example, you could ask the user for a passphrase and then use SecureAndroid like this:\r\n\r\n```Java\r\n// Encrypt a string with a given password\r\nbyte[] ciphertext = sc.encryptWithPassword(\"mystring\".getBytes(\"UTF-8\"), \"mypassword\".toCharArray());\r\n// Decrypt the string with the password\r\nString mystring = new String(sc.decryptWithPassword(ciphertext, \"mypassword\".toCharArray()), \"UTF-8\");\r\n```\r\n\r\n\r\n### encryptAndStore/retrieve\r\nSecureAndroid does not only provide you with methods to simply encrypt and decrypt binary data that you can then handle yourself but also with methods to encrypt and directly store data. This abstracts i/o-operations. You simply have to remember the alias under which you want the data to be stored. Again, with the encryptAndStore/retrieve methods an auto-generated password is used. You can choose whether you want to store the data in the SharedPreferences or in a file with the MODE flag-option: SecureAndroid.FILE or SecureAndroid.SHARED_PREFERENCES. \r\nNote: If you want to store larger binary data the use of FILE should be preferred.\r\n\r\n```Java\r\n// Encrypt a string and store it under the given alias in FILE mode\r\nsc.encryptAndStore(SecureAndroid.FILE, \"mystring\".getBytes(\"UTF-8\"), \"data_alias\");\r\n// Retrieve the string\r\nString mystring = new String(sc.retrieve(SecureAndroid.FILE, \"data_alias\"), \"UTF-8\");\r\n```\r\n\r\n### encryptAndStoreWithPassword/retrieveWithPassword\r\nThe encryptAndStoreWithPassword and retrieveWithPassword methods provide the same functionality as the above methods only that you can provide your own password. See # encryptWithPassword.\r\n\r\n```Java\r\n// Encrypt a string with password and store it under the given alias in FILE mode\r\nsc.encryptAndStoreWithPassword(SecureAndroid.FILE, \"mystring\".getBytes(\"UTF-8\"), \"data_alias\", \"mypassword\".toCharArray());\r\n// Retrieve\r\nString mystring = new String(sc.retrieveWithPassword(SecureAndroid.FILE, \"data_alias\", \"mypassword\".toCharArray()), \"UTF-8\");\r\n```\r\n\r\n### wipeKey\r\nIn case you want to make all data that you have encrypted using SecureAndroid inaccessible and thus destroy it, you can simply wipe the key that was used to perform the cryptographic operations. That destroys the data since that key was generated completely (pseudo)-random. \r\n```Java\r\n// Wipe key and thus wipe data\r\nsc.wipeKey();\r\n```\r\n\r\n### deleteData\r\nIf you want to delete a specific file or a shared pref\r\nerence you can do that by calling:\r\n```Java\r\n// Delete specific data\r\nsc.deleteData(SecureAndroid.FILE, \"data_alias\");\r\nsc.deleteData(SecureAndroid.SHARED_PREFERENCES, \"another_data_alias\");\r\n\r\n```\r\n\r\n### Exceptions\r\nNote that SecureAndroid will throw some useful exceptions if something wrong, for example if the wrong password was provided or you want to retrieve data that does not exist. See the javadocs for details.\r\n\r\n\r\n### How does it work under the hood?\r\nSecureAndroid takes an intermediate-key approach. All data is encrypted with AES-128 in CBC-Mode and Padding according to PKCS5. The integrity is checked with HmacSHA256/HmacSHA1, according to the availability on the device. The AES- and MAC-Keys used for enc- and decryption are themselves encrypted with an AES- and MAC-Masterkey and then stored on the device in encrypted form. The Masterkeys themselves are never stored on the device but are derived by PBKDFHmacSHA256/SHA1 on enc- or decryption.\r\n\r\n### What password is used for deriving the master-keys?\r\nIf you simply use the encrypt and decrypt-methods an automatic password is generated and then fed into the PBKDF2. That password is a hash of device information and therefore bound to a device. _That means you cannot decrypt something only on the device it was encrypted with_. \r\n\r\nIf you provide a password yourself or ask the user to provide one, that passphrase then is used to derive the keys. The intermediate keys are generated on the _first encryption operation_. In all subsequent encryption- or decryption processes these intermediate keys are use. \r\n_Note_: If you use SecureAndroid in an app, this means that the key-material will be deleted on app-deletion because it is stored in the apps SharedPreferences. If data should survive an app-uninstallation, you must provide that mechanism.\r\n\r\n### Where is data stored?\r\nAll key material is stored in the SharedPreferences of the app that you are using SecureAndroid with. The encrypted data is stored either in the SharedPreferences or in a file, according the mode-flag (see Javadocs or explanation above).\r\n\r\n ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}